<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>New Web, New World</title>
    <script type="text/javascript">
        function OnDockdemo() {
            hubble.sendMessage("TANGRAM_UI_MESSAGE", "xx", "", document.getElementById("dockdemo").outerHTML);
            document.getElementById("testbtn").style.display = "none";
        }
    </script>
</head>
<body background="newworld.jpg">
    <x style="font-size:40px; color:crimson">艳阳的.NET<strong><i style="font-size:40px; color:fuchsia">新 </i>世界</strong></x>
    <p><center><strong style="font-size:36px; color:blue">一个全新的Web在这里拉开了帷幕...</strong></center></p>
    <strong style="font-size:32px; color:darkred">Dock：既熟悉又陌生的属性</strong>
    <p style="font-size: 20px; font-weight:bold; color:midnightblue">
        每一个.NET UI(WinForm、Usercontrol、WPF)对象都拥有Dock属性，自从.NET Framework诞生以来，
        这个属性一直都存在。长年以来，我们已经习惯了Dock属性的<i style="font-weight:bold; color:red">约定成熟 </i>的使用方式，进而思维陷入了惯性，
        形成了盲点。一般说来，Dock属性将UI对象分为两大类:
        <center>
            <table border="1">
                <thead>
                    <tr style="font-size: 18px; font-weight:bold; color:midnightblue">
                        <th> 第一类Dock属性值
                        <th> 第二类Dock属性值
                    </tr>
                <tbody>
                    <tr>
                        <td>
                            <ol style="font-size: 20px; font-weight:900; color:darkblue">
                                <li>DockStyle.None</li>
                                <li>DockStyle.Fill</li>
                            </ol>
                        </td>
                        <td>
                            <ol style="font-size: 18px; font-weight:900; color:mediumvioletred">
                                <li>DockStyle.Left</li>
                                <li>DockStyle.Top</li>
                                <li>DockStyle.Right</li>
                                <li>DockStyle.Bottom</li>
                            </ol>
                        </td>
                </tbody>
            </table>
        </center>
    <p style="font-size: 20px; font-weight:bold; color:midnightblue">
        由于Dock属性为第二类的控件必须依赖于某个特定的控件，这种依赖关系确定了<i style=" font-weight: bold;
        color: red; text-decoration: underline">这类控件一般不能成为某类内容的主体承载控件</i>。
    </p>
    <p style="font-size: 20px; font-weight:bold; color:midnightblue">
        第一类控件包含如下两种情况：
        <ul style="font-size: 18px; font-weight:900; color:mediumvioletred">
            <li>控件本身是另外一个.NET UI控件的子对象</li>
            <li>是另外一个非.NET UI对象的子窗口(DockStyle.None)</li>
        </ul>
    </p>
    <p style="font-size: 20px; font-weight:bold; color:midnightblue">
        一般情况下，一个WinForm窗体，会至少包含一个第一类.NET UI对象。
    </p>

    <strong style="font-size:32px; color:darkred">动态编程从第一类控件开始...</strong>
    <p>
        <button style="font-size: 20px; font-weight:bold; color:midnightblue" onclick="OnDockdemo()">让我们看看，Dock属性究竟隐藏了什么？Press me to continus...</button>
    </p>
    <layout>
        <dockdemo id="dockdemo">
            <layout>
                <g style="17">
                    <g rows="1" cols="2" width="200,300" caption="New Web,New World">
                        <g rows="2" cols="1" height="200,300">
                            <g objid="nucleus"></g>
                            <g objid="SunnyCtrl.democtrl,SunnyCtrl"></g>
                        </g>
                        <g style="18" caption="Introduction to Open Universe">
                            <g caption="Using WinForm"></g>
                            <g caption="Using WPF Control"></g>
                            <g caption="Using UserControl"></g>
                        </g>
                    </g>
                </g>
            </layout>
        </dockdemo>
    </layout>
</body>
</html>